# HelixDB Schema for hbd - Git-first Issue Tracker
#
# This schema defines the graph structure for issue tracking:
# - Nodes: Issue, Comment, Label, User, Project
# - Edges: DEPENDS_ON, PARENT_OF, COMMENT_ON, TAGGED, ASSIGNED_TO, etc.
# - Vectors: IssueEmbedding for semantic search
#
# Schema inspired by wedow/ticket's Markdown-first approach,
# with HelixDB providing fast graph traversal and search.

# =============================================================================
#                                 NODES
# =============================================================================

# Core issue tracking node
N::Issue {
    # Identity - hash-based ID for conflict-free git merges
    INDEX id: String,                     # e.g., "bd-a1b2c3"
    
    # Core fields
    title: String,
    body: String,                         # Markdown description
    status: String,                       # open | in_progress | blocked | closed
    priority: I32,                        # 0=critical, 1=high, 2=medium, 3=low, 4=backlog
    issue_type: String,                   # bug | feature | task | epic | chore
    
    # Timestamps (ISO 8601)
    created_at: String,
    updated_at: String,
    closed_at: String,
    
    # Attribution
    created_by: String,                   # Username or agent ID
    created_by_type: String,              # human | agent
    assignee: String,
    
    # Agent tracking for AI workflows
    agent_id: String,                     # e.g., "claude", "cursor", "copilot"
    session_id: String,                   # Groups related agent actions
    
    # Extended fields
    external_ref: String,                 # GitHub/Jira/Linear link (e.g., "gh-123")
    source_repo: String,                  # For multi-repo support
    estimated_minutes: I32,               # Time estimate for planning
    
    # Parent issue ID (for epic hierarchy)
    parent_id: String,                    # Direct parent, empty if top-level
    
    # Sync metadata
    content_hash: String,                 # blake3 hash for change detection
}

# Comment on an issue
N::Comment {
    INDEX id: String,                     # UUID-based
    body: String,
    created_at: String,
    created_by: String,
    created_by_type: String,              # human | agent
    issue_id: String,                     # Denormalized for fast lookup
}

# Label for categorization
N::Label {
    INDEX name: String,                   # e.g., "bug", "mvp", "backend"
    color: String,                        # Hex color: "#ff0000"
    description: String,
}

# User (human or agent)
N::User {
    INDEX handle: String,                 # Unique identifier
    name: String,                         # Display name
    email: String,
    user_type: String,                    # human | agent
    agent_id: String,                     # If user_type=agent, the agent identifier
}

# Project for multi-project support
N::Project {
    INDEX name: String,
    description: String,
    prefix: String,                       # ID prefix, e.g., "hbd" for "hbd-a1b2"
}

# =============================================================================
#                              VECTOR NODES
# =============================================================================

# Embedding for semantic search on issues
V::IssueEmbedding {
    issue_id: String,                     # Reference to Issue.id
    text_hash: String,                    # Hash of embedded text for staleness check
    model: String,                        # e.g., "fastembed:bge-small-en-v1.5"
    # Implicit: 384-dimensional vector for BGE-small-en-v1.5
}

# =============================================================================
#                                 EDGES
# =============================================================================

# Dependency between issues
# Direction: FROM depends on TO (FROM is blocked by TO)
# Example: "bd-child DEPENDS_ON bd-blocker" means child waits for blocker
E::DEPENDS_ON {
    From: Issue,
    To: Issue,
    Properties: {
        dep_type: String,                 # blocks | related | waits_for
        created_at: String,
        created_by: String,
    }
}

# Parent-child hierarchy (epics)
# Direction: FROM is parent of TO
# Example: "bd-epic PARENT_OF bd-task"
E::PARENT_OF {
    From: Issue,
    To: Issue,
    Properties: {
        created_at: String,
    }
}

# Comment belongs to issue
E::COMMENT_ON {
    From: Comment,
    To: Issue,
}

# Issue has label
E::TAGGED {
    From: Issue,
    To: Label,
}

# Issue assigned to user
E::ASSIGNED_TO {
    From: Issue,
    To: User,
}

# Issue created by user
E::AUTHORED {
    From: User,
    To: Issue,
}

# Comment created by user
E::COMMENTED {
    From: User,
    To: Comment,
}

# Issue belongs to project
E::IN_PROJECT {
    From: Issue,
    To: Project,
}

# Issue has embedding (for semantic search)
E::HAS_EMBEDDING {
    From: Issue,
    To: IssueEmbedding,
}

# =============================================================================
#                                QUERIES
# =============================================================================

# Get issue by ID with all relationships
QUERY getIssue(issue_id: String) =>
    issue <- N<Issue>::WHERE(_::{id}::EQ(issue_id))
    
    labels <- issue::Out<TAGGED>::{name, color}
    comments <- issue::In<COMMENT_ON>
        ::ORDER<Asc>(_::{created_at})
        ::{id, body, created_at, created_by, created_by_type}
    
    blockers <- issue::Out<DEPENDS_ON>
        ::WHERE(_::{dep_type}::EQ("blocks"))
        ::{id, title, status, priority}
    
    blocked_by <- issue::In<DEPENDS_ON>
        ::WHERE(_::{dep_type}::EQ("blocks"))
        ::{id, title, status, priority}
    
    children <- issue::Out<PARENT_OF>::{id, title, status, priority}
    parent <- N<Issue>::WHERE(_::{id}::EQ(issue::{parent_id}))::{id, title}
    
    RETURN {
        issue: issue,
        labels: labels,
        comments: comments,
        blockers: blockers,
        blocked_by: blocked_by,
        children: children,
        parent: parent
    }

# List issues with filters
QUERY listIssues(status: String, issue_type: String, priority: I32) =>
    issues <- N<Issue>
        ::WHERE(OR(status::EQ(""), _::{status}::EQ(status)))
        ::WHERE(OR(issue_type::EQ(""), _::{issue_type}::EQ(issue_type)))
        ::WHERE(OR(priority::EQ(-1), _::{priority}::EQ(priority)))
        ::ORDER<Asc>(_::{priority})
        ::ORDER<Desc>(_::{created_at})
    
    RETURN issues::{id, title, status, priority, issue_type, assignee, created_at}

# Get ready issues (no open blockers)
QUERY readyIssues() =>
    issues <- N<Issue>
        ::WHERE(_::{status}::EQ("open"))
        ::WHERE(
            NOT(EXISTS(
                _::Out<DEPENDS_ON>
                    ::WHERE(_::{dep_type}::EQ("blocks"))
                    ::WHERE(_::{status}::NEQ("closed"))
            ))
        )
        ::ORDER<Asc>(_::{priority})
        ::ORDER<Desc>(_::{created_at})
    
    RETURN issues::{id, title, priority, assignee, created_at}

# Get blocked issues with blockers
QUERY blockedIssues() =>
    issues <- N<Issue>
        ::WHERE(
            OR(
                _::{status}::EQ("blocked"),
                EXISTS(
                    _::Out<DEPENDS_ON>
                        ::WHERE(_::{dep_type}::EQ("blocks"))
                        ::WHERE(_::{status}::NEQ("closed"))
                )
            )
        )
        ::WHERE(_::{status}::NEQ("closed"))
    
    FOR issue IN issues {
        blockers <- issue::Out<DEPENDS_ON>
            ::WHERE(_::{dep_type}::EQ("blocks"))
            ::WHERE(_::{status}::NEQ("closed"))
            ::{id, title, status, assignee}
    }
    
    RETURN {
        issue: issues::{id, title, priority},
        blockers: blockers
    }

# Detect if adding dependency would create cycle
QUERY detectCycle(from_id: String, to_id: String) =>
    # Check if 'to' can reach 'from' via existing DEPENDS_ON edges
    path <- N<Issue>::WHERE(_::{id}::EQ(to_id))
        ::Out<DEPENDS_ON>*
        ::WHERE(_::{id}::EQ(from_id))
    
    RETURN {
        would_cycle: EXISTS(path),
        path: path::{id}
    }

# BM25 text search
QUERY searchIssues(query: String, limit: I32) =>
    results <- SearchBM25<Issue>(query, limit)
    RETURN results::{id, title, status, priority, score: _::score}

# Semantic similarity search
QUERY findSimilar(issue_id: String, limit: I32) =>
    source <- N<Issue>::WHERE(_::{id}::EQ(issue_id))::Out<HAS_EMBEDDING>
    
    similar <- SearchV<IssueEmbedding>(source, limit)
        ::In<HAS_EMBEDDING>
        ::WHERE(_::{id}::NEQ(issue_id))
        ::{id, title, status, similarity: _::score}
    
    RETURN similar
