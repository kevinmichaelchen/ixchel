---
title: Architecture
description: How Helix Tools are structured
---

# Architecture

Helix Tools share a common architecture that balances simplicity with power.

## Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                         CLI Tools Layer                              │
│                                                                      │
│   hbd                  ixchel                demo-got              │
│   (issues)             (knowledge weaving)   (example project)     │
│                                                                      │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
┌──────────────────────────────┴──────────────────────────────────────┐
│                        Shared Libraries                              │
│                                                                      │
│   ix-id     ix-config     ix-embeddings     ix-core                │
│   (hash IDs) (settings)   (embedders)       (domain logic)         │
│                                                                      │
└──────────────────────────────┬──────────────────────────────────────┘
                               │
┌──────────────────────────────┴──────────────────────────────────────┐
│                           HelixDB                                    │
│                                                                      │
│   Graph Engine    Vector Search    BM25 Index    LMDB Storage       │
│   (traversals)    (HNSW)           (text)        (persistence)      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

## Data Flow

Every tool follows the same pattern:

### Write Path

1. User/agent creates or modifies data via CLI
2. Changes are written to git-tracked files (Markdown/YAML)
3. Data is indexed in HelixDB for fast querying
4. Embeddings are generated asynchronously

### Read Path

1. Query comes in (keyword, semantic, or hybrid)
2. HelixDB returns results using appropriate index
3. Results are formatted for human or agent consumption

### Sync Path

When you `git pull` new changes:

1. File watcher detects changes in tracked directories
2. Changed files are parsed and validated
3. HelixDB is updated to match file state
4. Embeddings are regenerated if text content changed

## Technology Stack

| Component | Technology | Why |
|-----------|------------|-----|
| Language | Rust | Performance, safety, HelixDB compatibility |
| Database | HelixDB | Graph + vector + BM25 in one |
| Embeddings | fastembed | Native Rust, offline, no server |
| CLI | clap | Standard Rust CLI framework |
| Git ops | gix | Pure Rust git implementation |
| Hashing | Blake3 | Fast cryptographic hashing for IDs |

## Project Structure

```
ixchel-tools/
├── apps/
│   ├── hbd/                 # Issue tracker CLI
│   ├── hbd-ui/              # Svelte UI for hbd (frontend)
│   │   └── src-tauri/       # Tauri shell (Rust)
│   ├── demo-got/            # Demo project (HelixDB + ix-embeddings)
│   ├── ix-cli/              # ixchel CLI (binary)
│   ├── ix-daemon/           # Background daemon + IPC (binary: ixcheld)
│   └── ix-mcp/              # ixchel MCP server
│
├── crates/
│   ├── ix-app/              # ixchel wiring layer
│   ├── ix-core/             # ixchel core library
│   ├── ix-storage-helixdb/  # HelixDB-backed cache/index for ixchel
│   ├── ix-id/               # Hash-based ID generation
│   ├── ix-config/           # Configuration loading
│   ├── ix-embeddings/       # Pluggable embedding providers
│   └── ix-helixdb-ops/       # HelixDB helper crate
│
├── docs/                   # This documentation site
│
├── Cargo.toml              # Workspace root
└── README.md
```

Each tool includes Kiro-style specifications in a `specs/` directory:
- `requirements.md` - User stories (EARS notation)
- `design.md` - Technical architecture
- `tasks.md` - Implementation roadmap
